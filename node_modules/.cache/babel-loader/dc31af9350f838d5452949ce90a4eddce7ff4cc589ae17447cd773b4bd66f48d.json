{"ast":null,"code":"import { useEffect, useMemo, useState } from 'react';\nexport var ZoomState;\n(function (ZoomState) {\n  ZoomState[\"ZOOMING_IN\"] = \"ZOOMING_IN\";\n  ZoomState[\"ZOOMING_OUT\"] = \"ZOOMING_OUT\";\n})(ZoomState || (ZoomState = {}));\nvar usePinchZoom = function usePinchZoom(ref) {\n  var cacheRef = useMemo(function () {\n    return {\n      evCache: [],\n      prevDiff: -1\n    };\n  }, [ref.current]);\n  var _a = useState(),\n    zoomingState = _a[0],\n    setZoomingState = _a[1];\n  var pointermove_handler = function pointermove_handler(ev) {\n    // This function implements a 2-pointer horizontal pinch/zoom gesture.\n    //\n    // If the distance between the two pointers has increased (zoom in),\n    // the target element's background is changed to 'pink' and if the\n    // distance is decreasing (zoom out), the color is changed to 'lightblue'.\n    //\n    // This function sets the target element's border to 'dashed' to visually\n    // indicate the pointer's target received a move event.\n    // Find this event in the cache and update its record with this event\n    for (var i = 0; i < cacheRef.evCache.length; i++) {\n      if (ev.pointerId == cacheRef.evCache[i].pointerId) {\n        cacheRef.evCache[i] = ev;\n        break;\n      }\n    }\n    // If two pointers are down, check for pinch gestures\n    if (cacheRef.evCache.length == 2) {\n      // console.log(prevDiff)\n      // Calculate the distance between the two pointers\n      var curDiff = Math.abs(cacheRef.evCache[0].clientX - cacheRef.evCache[1].clientX);\n      if (cacheRef.prevDiff > 0) {\n        if (curDiff > cacheRef.prevDiff) {\n          // The distance between the two pointers has increased\n          setZoomingState([ZoomState.ZOOMING_IN, curDiff]);\n        }\n        if (curDiff < cacheRef.prevDiff) {\n          // The distance between the two pointers has decreased\n          setZoomingState([ZoomState.ZOOMING_OUT, curDiff]);\n        }\n      }\n      // Cache the distance for the next move event\n      cacheRef.prevDiff = curDiff;\n    }\n  };\n  var pointerdown_handler = function pointerdown_handler(ev) {\n    // The pointerdown event signals the start of a touch interaction.\n    // This event is cached to support 2-finger gestures\n    cacheRef.evCache.push(ev);\n    // console.log('pointerDown', ev);\n  };\n\n  var pointerup_handler = function pointerup_handler(ev) {\n    // Remove this pointer from the cache and reset the target's\n    // background and border\n    remove_event(ev);\n    // If the number of pointers down is less than two then reset diff tracker\n    if (cacheRef.evCache.length < 2) {\n      cacheRef.prevDiff = -1;\n    }\n  };\n  var remove_event = function remove_event(ev) {\n    // Remove this event from the target's cache\n    for (var i = 0; i < cacheRef.evCache.length; i++) {\n      if (cacheRef.evCache[i].pointerId == ev.pointerId) {\n        cacheRef.evCache.splice(i, 1);\n        break;\n      }\n    }\n  };\n  useEffect(function () {\n    if (ref === null || ref === void 0 ? void 0 : ref.current) {\n      ref.current.onpointerdown = pointerdown_handler;\n      ref.current.onpointermove = pointermove_handler;\n      ref.current.onpointerup = pointerup_handler;\n      ref.current.onpointercancel = pointerup_handler;\n      ref.current.onpointerout = pointerup_handler;\n      ref.current.onpointerleave = pointerup_handler;\n    }\n  }, [ref === null || ref === void 0 ? void 0 : ref.current]);\n  return zoomingState ? {\n    zoomingState: zoomingState[0],\n    pinchState: zoomingState[1]\n  } : {\n    zoomingState: null,\n    pinchState: 0\n  };\n};\nexport default usePinchZoom;","map":{"version":3,"names":["useEffect","useMemo","useState","ZoomState","usePinchZoom","ref","cacheRef","evCache","prevDiff","current","_a","zoomingState","setZoomingState","pointermove_handler","ev","i","length","pointerId","curDiff","Math","abs","clientX","ZOOMING_IN","ZOOMING_OUT","pointerdown_handler","push","pointerup_handler","remove_event","splice","onpointerdown","onpointermove","onpointerup","onpointercancel","onpointerout","onpointerleave","pinchState"],"sources":["/Users/anastasiazhuravleva/CODING/PROJECTS/todo-app-v5/node_modules/react-use/esm/usePinchZoom.js"],"sourcesContent":["import { useEffect, useMemo, useState } from 'react';\nexport var ZoomState;\n(function (ZoomState) {\n    ZoomState[\"ZOOMING_IN\"] = \"ZOOMING_IN\";\n    ZoomState[\"ZOOMING_OUT\"] = \"ZOOMING_OUT\";\n})(ZoomState || (ZoomState = {}));\nvar usePinchZoom = function (ref) {\n    var cacheRef = useMemo(function () { return ({\n        evCache: [],\n        prevDiff: -1,\n    }); }, [ref.current]);\n    var _a = useState(), zoomingState = _a[0], setZoomingState = _a[1];\n    var pointermove_handler = function (ev) {\n        // This function implements a 2-pointer horizontal pinch/zoom gesture.\n        //\n        // If the distance between the two pointers has increased (zoom in),\n        // the target element's background is changed to 'pink' and if the\n        // distance is decreasing (zoom out), the color is changed to 'lightblue'.\n        //\n        // This function sets the target element's border to 'dashed' to visually\n        // indicate the pointer's target received a move event.\n        // Find this event in the cache and update its record with this event\n        for (var i = 0; i < cacheRef.evCache.length; i++) {\n            if (ev.pointerId == cacheRef.evCache[i].pointerId) {\n                cacheRef.evCache[i] = ev;\n                break;\n            }\n        }\n        // If two pointers are down, check for pinch gestures\n        if (cacheRef.evCache.length == 2) {\n            // console.log(prevDiff)\n            // Calculate the distance between the two pointers\n            var curDiff = Math.abs(cacheRef.evCache[0].clientX - cacheRef.evCache[1].clientX);\n            if (cacheRef.prevDiff > 0) {\n                if (curDiff > cacheRef.prevDiff) {\n                    // The distance between the two pointers has increased\n                    setZoomingState([ZoomState.ZOOMING_IN, curDiff]);\n                }\n                if (curDiff < cacheRef.prevDiff) {\n                    // The distance between the two pointers has decreased\n                    setZoomingState([ZoomState.ZOOMING_OUT, curDiff]);\n                }\n            }\n            // Cache the distance for the next move event\n            cacheRef.prevDiff = curDiff;\n        }\n    };\n    var pointerdown_handler = function (ev) {\n        // The pointerdown event signals the start of a touch interaction.\n        // This event is cached to support 2-finger gestures\n        cacheRef.evCache.push(ev);\n        // console.log('pointerDown', ev);\n    };\n    var pointerup_handler = function (ev) {\n        // Remove this pointer from the cache and reset the target's\n        // background and border\n        remove_event(ev);\n        // If the number of pointers down is less than two then reset diff tracker\n        if (cacheRef.evCache.length < 2) {\n            cacheRef.prevDiff = -1;\n        }\n    };\n    var remove_event = function (ev) {\n        // Remove this event from the target's cache\n        for (var i = 0; i < cacheRef.evCache.length; i++) {\n            if (cacheRef.evCache[i].pointerId == ev.pointerId) {\n                cacheRef.evCache.splice(i, 1);\n                break;\n            }\n        }\n    };\n    useEffect(function () {\n        if (ref === null || ref === void 0 ? void 0 : ref.current) {\n            ref.current.onpointerdown = pointerdown_handler;\n            ref.current.onpointermove = pointermove_handler;\n            ref.current.onpointerup = pointerup_handler;\n            ref.current.onpointercancel = pointerup_handler;\n            ref.current.onpointerout = pointerup_handler;\n            ref.current.onpointerleave = pointerup_handler;\n        }\n    }, [ref === null || ref === void 0 ? void 0 : ref.current]);\n    return zoomingState\n        ? { zoomingState: zoomingState[0], pinchState: zoomingState[1] }\n        : { zoomingState: null, pinchState: 0 };\n};\nexport default usePinchZoom;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}