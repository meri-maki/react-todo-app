{"ast":null,"code":"import { useCallback, useMemo, useRef, useState } from 'react';\nimport { useFirstMountState } from './useFirstMountState';\nimport { resolveHookState } from './misc/hookState';\nexport function useStateWithHistory(initialState, capacity, initialHistory) {\n  if (capacity === void 0) {\n    capacity = 10;\n  }\n  if (capacity < 1) {\n    throw new Error(\"Capacity has to be greater than 1, got '\" + capacity + \"'\");\n  }\n  var isFirstMount = useFirstMountState();\n  var _a = useState(initialState),\n    state = _a[0],\n    innerSetState = _a[1];\n  var history = useRef(initialHistory !== null && initialHistory !== void 0 ? initialHistory : []);\n  var historyPosition = useRef(0);\n  // do the states manipulation only on first mount, no sense to load re-renders with useless calculations\n  if (isFirstMount) {\n    if (history.current.length) {\n      // if last element of history !== initial - push initial to history\n      if (history.current[history.current.length - 1] !== initialState) {\n        history.current.push(initialState);\n      }\n      // if initial history bigger that capacity - crop the first elements out\n      if (history.current.length > capacity) {\n        history.current = history.current.slice(history.current.length - capacity);\n      }\n    } else {\n      // initiate the history with initial state\n      history.current.push(initialState);\n    }\n    historyPosition.current = history.current.length && history.current.length - 1;\n  }\n  var setState = useCallback(function (newState) {\n    innerSetState(function (currentState) {\n      newState = resolveHookState(newState, currentState);\n      // is state has changed\n      if (newState !== currentState) {\n        // if current position is not the last - pop element to the right\n        if (historyPosition.current < history.current.length - 1) {\n          history.current = history.current.slice(0, historyPosition.current + 1);\n        }\n        historyPosition.current = history.current.push(newState) - 1;\n        // if capacity is reached - shift first elements\n        if (history.current.length > capacity) {\n          history.current = history.current.slice(history.current.length - capacity);\n        }\n      }\n      return newState;\n    });\n  }, [state, capacity]);\n  var historyState = useMemo(function () {\n    return {\n      history: history.current,\n      position: historyPosition.current,\n      capacity: capacity,\n      back: function (amount) {\n        if (amount === void 0) {\n          amount = 1;\n        }\n        // don't do anything if we already at the left border\n        if (!historyPosition.current) {\n          return;\n        }\n        innerSetState(function () {\n          historyPosition.current -= Math.min(amount, historyPosition.current);\n          return history.current[historyPosition.current];\n        });\n      },\n      forward: function (amount) {\n        if (amount === void 0) {\n          amount = 1;\n        }\n        // don't do anything if we already at the right border\n        if (historyPosition.current === history.current.length - 1) {\n          return;\n        }\n        innerSetState(function () {\n          historyPosition.current = Math.min(historyPosition.current + amount, history.current.length - 1);\n          return history.current[historyPosition.current];\n        });\n      },\n      go: function (position) {\n        if (position === historyPosition.current) {\n          return;\n        }\n        innerSetState(function () {\n          historyPosition.current = position < 0 ? Math.max(history.current.length + position, 0) : Math.min(history.current.length - 1, position);\n          return history.current[historyPosition.current];\n        });\n      }\n    };\n  }, [state]);\n  return [state, setState, historyState];\n}","map":{"version":3,"names":["useCallback","useMemo","useRef","useState","useFirstMountState","resolveHookState","useStateWithHistory","initialState","capacity","initialHistory","Error","isFirstMount","_a","state","innerSetState","history","historyPosition","current","length","push","slice","setState","newState","currentState","historyState","position","back","amount","Math","min","forward","go","max"],"sources":["/Users/anastasiazhuravleva/CODING/PROJECTS/todo-app-v5/node_modules/react-use/esm/useStateWithHistory.js"],"sourcesContent":["import { useCallback, useMemo, useRef, useState } from 'react';\nimport { useFirstMountState } from './useFirstMountState';\nimport { resolveHookState } from './misc/hookState';\nexport function useStateWithHistory(initialState, capacity, initialHistory) {\n    if (capacity === void 0) { capacity = 10; }\n    if (capacity < 1) {\n        throw new Error(\"Capacity has to be greater than 1, got '\" + capacity + \"'\");\n    }\n    var isFirstMount = useFirstMountState();\n    var _a = useState(initialState), state = _a[0], innerSetState = _a[1];\n    var history = useRef((initialHistory !== null && initialHistory !== void 0 ? initialHistory : []));\n    var historyPosition = useRef(0);\n    // do the states manipulation only on first mount, no sense to load re-renders with useless calculations\n    if (isFirstMount) {\n        if (history.current.length) {\n            // if last element of history !== initial - push initial to history\n            if (history.current[history.current.length - 1] !== initialState) {\n                history.current.push(initialState);\n            }\n            // if initial history bigger that capacity - crop the first elements out\n            if (history.current.length > capacity) {\n                history.current = history.current.slice(history.current.length - capacity);\n            }\n        }\n        else {\n            // initiate the history with initial state\n            history.current.push(initialState);\n        }\n        historyPosition.current = history.current.length && history.current.length - 1;\n    }\n    var setState = useCallback(function (newState) {\n        innerSetState(function (currentState) {\n            newState = resolveHookState(newState, currentState);\n            // is state has changed\n            if (newState !== currentState) {\n                // if current position is not the last - pop element to the right\n                if (historyPosition.current < history.current.length - 1) {\n                    history.current = history.current.slice(0, historyPosition.current + 1);\n                }\n                historyPosition.current = history.current.push(newState) - 1;\n                // if capacity is reached - shift first elements\n                if (history.current.length > capacity) {\n                    history.current = history.current.slice(history.current.length - capacity);\n                }\n            }\n            return newState;\n        });\n    }, [state, capacity]);\n    var historyState = useMemo(function () { return ({\n        history: history.current,\n        position: historyPosition.current,\n        capacity: capacity,\n        back: function (amount) {\n            if (amount === void 0) { amount = 1; }\n            // don't do anything if we already at the left border\n            if (!historyPosition.current) {\n                return;\n            }\n            innerSetState(function () {\n                historyPosition.current -= Math.min(amount, historyPosition.current);\n                return history.current[historyPosition.current];\n            });\n        },\n        forward: function (amount) {\n            if (amount === void 0) { amount = 1; }\n            // don't do anything if we already at the right border\n            if (historyPosition.current === history.current.length - 1) {\n                return;\n            }\n            innerSetState(function () {\n                historyPosition.current = Math.min(historyPosition.current + amount, history.current.length - 1);\n                return history.current[historyPosition.current];\n            });\n        },\n        go: function (position) {\n            if (position === historyPosition.current) {\n                return;\n            }\n            innerSetState(function () {\n                historyPosition.current =\n                    position < 0\n                        ? Math.max(history.current.length + position, 0)\n                        : Math.min(history.current.length - 1, position);\n                return history.current[historyPosition.current];\n            });\n        },\n    }); }, [state]);\n    return [state, setState, historyState];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}